//
// typewriter/go.rs
// The PHiLe Compiler
//
// Created by Arpad Goretity (H2CO3)
// on 12/07/2017
//

use std::io;
use codegen::*;
use sqir::*;
use util::PACKAGE_INFO;


//
// Type annotations for declarations, etc.
//

pub fn write_type(wr: &mut io::Write, ty: &WkType, params: &CodegenParams) -> io::Result<()> {
    let rc = ty.as_rc()?;
    let ptr = rc.borrow()?;

    match *ptr {
        Type::Bool  => write!(wr, "bool"),
        Type::Int   => write!(wr, "int64"),
        Type::Float => write!(wr, "float64"),
        Type::Decimal { .. } => unimplemented!(),

        Type::String => write!(wr, "string"),
        Type::Blob   => write!(wr, "[]byte"),
        Type::Date   => write!(wr, "time.Time"),

        Type::Optional(ref wrapped) => write_optional_type(wr, wrapped, params),
        Type::Pointer(ref pointed)  => write_pointer_type(wr, pointed, params),
        Type::Array(ref element)    => write_array_type(wr, element, params),
        Type::Tuple(ref types)      => write_tuple_type(wr, types, params),

        // Respect type name transform
        Type::Enum(ref et)   => write!(wr, "{}", transform_type_name(&et.name, params)),
        Type::Struct(ref st) => write!(wr, "{}", transform_type_name(&st.name, params)),
        Type::Class(ref ct)  => write!(wr, "{}", transform_type_name(&ct.name, params)),

        Type::Function(ref ft) => write_function_type(wr, ft, params),
        Type::Placeholder { ref name, kind } => unreachable!("Unresolved Placeholder({}, {:#?})", name, kind),
    }
}

fn write_optional_type(wr: &mut io::Write, wrapped: &WkType, params: &CodegenParams) -> io::Result<()> {
    write_pointer_type(wr, wrapped, params)
}

fn write_pointer_type(wr: &mut io::Write, pointed: &WkType, params: &CodegenParams) -> io::Result<()> {
    write!(wr, "*").and_then(|_| write_type(wr, pointed, params))
}

fn write_array_type(wr: &mut io::Write, element: &WkType, params: &CodegenParams) -> io::Result<()> {
    write!(wr, "[]").and_then(|_| write_type(wr, element, params))
}

fn write_tuple_type(wr: &mut io::Write, types: &[WkType], params: &CodegenParams) -> io::Result<()> {
    write!(wr, "struct {{ ")?;

    for (idx, typ) in types.iter().enumerate() {
        write!(wr, "F{} ", idx)?;
        write_type(wr, typ, params)?;
        write!(wr, "; ")?;
    }

    write!(wr, "}}")
}

fn write_function_type(wr: &mut io::Write, ty: &FunctionType, params: &CodegenParams) -> io::Result<()> {
    write!(wr, "func(")?;

    for (i, arg) in ty.arg_types.iter().enumerate() {
        if i > 0 {
            write!(wr, ", ")?;
        }

        write_type(wr, arg, params)?;
    }

    write!(wr, ") ")?;

    write_type(wr, &ty.ret_type, params)
}

//
// Package/namespace, include and dummy type uses
//

pub fn write_header(wr: &mut io::Write, params: &CodegenParams) -> io::Result<()> {
    write_comment_header(wr)?;
    write_namespace(wr, params)?;
    write_imports(wr, params)?;
    write_dummy_uses(wr, params)?;
    Ok(())
}

fn write_comment_header(wr: &mut io::Write) -> io::Result<()> {
    writeln!(wr, "//")?;
    writeln!(wr, "// Generated by PHiLe v{}", PACKAGE_INFO.version)?;
    writeln!(wr, "// Copyright (C) 2017, {}", PACKAGE_INFO.authors)?;
    writeln!(wr, "//")?;
    writeln!(wr)
}

// Namespace <-> package name
// Respect namespace transform
fn write_namespace(wr: &mut io::Write, params: &CodegenParams) -> io::Result<()> {
    let package_name = params.namespace.as_ref().map(
        |ns| transform_namespace(ns, params)
    ).ok_or_else(
        || io::Error::new(io::ErrorKind::InvalidInput, "Missing namespace")
    )?;

    writeln!(wr, "package {}\n", package_name)
}

fn write_imports(wr: &mut io::Write, params: &CodegenParams) -> io::Result<()> {
    // stdlib imports
    writeln!(wr, "import \"time\"")?;

    // driver-specific imports
    match params.database {
        DatabaseEngine::MongoDB => writeln!(wr, "import \"gopkg.in/mgo.v2\"")?,
        DatabaseEngine::MariaDB => unimplemented!(),
        DatabaseEngine::SQLite3 => unimplemented!(),
    }

    writeln!(wr)
}

fn write_dummy_uses(wr: &mut io::Write, params: &CodegenParams) -> io::Result<()> {
    // stdlib stuff is always imported and should be used
    writeln!(wr, "type _ time.Time")?;

    // driver imports are conditional, so are their dummy uses
    match params.database {
        DatabaseEngine::MongoDB => writeln!(wr, "type _ mgo.Session")?,
        DatabaseEngine::MariaDB => unimplemented!(),
        DatabaseEngine::SQLite3 => unimplemented!(),
    }

    writeln!(wr)
}
